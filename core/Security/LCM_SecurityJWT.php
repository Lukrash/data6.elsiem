<?php
require "LCM_ISecurity.php";

class LCMSecurityJWT implements LCM_ISecurity
{
    private $secretKey = "SecretKeyApiRestDeLasN4r1c35";
    private $expiredMin;
    private $key;
    private $subject;
    
    public function __construct($arrParams)
    {
        $this->expiredMin = $arrParams["MinutesExpired"];
        $this->key = $arrParams["Key"];
        $this->subject = $arrParams["Subject"];
    }

    public function GetPublicInfo(){
        return array(
            "type" => "JWT",
            "desc" => "JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties",
            "info" => "https://jwt.io/",
            "state" => "active"
        );
    }

    public function CheckSecurity($controller, $action){
        error_log("CheckSecurity JWT");
        $response = null;
        $prefixError = "Unauthorized. Method '". $action ."' protected.";

        $authorization = $this->getAuthorizationHeader();
        
        // Chequea si viene el header authorization
        if(empty($authorization)){
            $response = array(
                "httpstatus" => "401",
                "code" => "13001",
                "message" => $prefixError." There isn't Authorization header in your request.",
            );
            return $response;
        }

        //Chequea si esta bien marcado el esquema de autorización
        $arrAuth = explode(" ", $authorization);
        if($arrAuth[0] != "Bearer"){
            $response =  array(
                "httpstatus" => "401",
                "code" => "13002",
                "message" => $prefixError." Authorization header schema wrong.",
            );
            return $response;
        }

        //Comprobamos que viene token en el campo Authorization
        $jwtToken = $arrAuth[1];
        if(empty($jwtToken)){
            $response =  array(
                "httpstatus" => "401",
                "code" => "13003",
                "message" => $prefixError." Authorization header without token.",
            );
            return $response;
        }

        if(!$this->IsTokenValid($jwtToken)){
            $response =  array(
                "httpstatus" => "401",
                "code" => "13004",
                "message" => $prefixError." Access denied. Invalid token.",
            );
            return $response;
        }


        return $response;

    }

    /**
     * Chequea si el token pasado por parámetro es valido
     */
    public function IsTokenValid($jwtToken){
        // Split a string by '.' 
        $jwt_values = explode('.', $jwtToken);

        // extracting the signature from the original JWT 
        $recieved_signature = $jwt_values[2];

        // concatenating the first two arguments of the $jwt_values array, representing the header and the payload
        $recievedHeaderAndPayload = $jwt_values[0] . '.' . $jwt_values[1];

        // creating the Base 64 encoded new signature generated by applying the HMAC method to the concatenated header and payload values
        $resultedsignature = base64_encode(hash_hmac('sha256', $recievedHeaderAndPayload, $this->secretKey, true));

        // checking if the created signature is equal to the received signature
        if($resultedsignature == $recieved_signature) {
            return true;
        } else {
            return false;
        }
    }

    public function GetToken($key64){
        $key = base64_decode($key64);

        //Expired time
        $fecha = date("Y-m-d H:i:s");
        $newFecha = strtotime ( '+' . $this->expiredMin .' minute' , strtotime ( $fecha ));
        $expiredDate = date('Y-m-d H:i:s', $newFecha);

        //Si la llave es correcta genera un token valido
        if($this->key === $key){
            $payload = array(
                "iss" => "elsiemFramework",
                "exp" => $expiredDate,
                "sub" => $this->subject
            );
            return $this->GenerateToken($payload);
        }
        return "";
    }




    /**
     * Genera un token valido para un usuario
     */
    public function GenerateToken ($arrPayload){
        // base64 encodes the header json
        $arrheader = array('alg' => 'HS256', 'typ' => 'JWT');
        $jsonheader = json_encode($arrheader);
        $encoded_header = base64_encode($jsonheader);

        // base64 encodes the payload json
        $jsonPayload = json_encode($arrPayload);
        $encoded_payload = base64_encode($jsonPayload);

        // base64 strings are concatenated to one that looks like this
        $header_payload = $encoded_header . '.' . $encoded_payload;

        // Creating the signature, a hash with the s256 algorithm and the secret key. The signature is also base64 encoded.
        $signature = base64_encode(hash_hmac('sha256', $header_payload, $this->secretKey, true));

        // Creating the JWT token by concatenating the signature with the header and payload, that looks like this:
        $jwt_token = $header_payload . '.' . $signature;

        //listing the resulted  JWT
        return $jwt_token;
    }

    /**
     * Devuelve el Header del JWT
     */
    private function getHeaderJWT($jwtCode){
        // Split a string by '.' 
        $jwt_values = explode('.', $jwtCode);
        $header = $jwt_values[0];
        return $header;
    }

    /**
     * Devuelve el Payload del JWT decodificado (array) o sin descodificar (string)
     */
    private function getPayloadJWT($jwtCode,$decode=false){
        // Split a string by '.' 
        $jwt_values = explode('.', $jwtCode);
        $payload = $jwt_values[1];
        if($decode){
            $payload = json_decode(base64_decode($jwt_values[1]),true);
        }
        return $payload;
    }

    /**
     * Devuelve el Signing del JWT
     */
    private function getSigningJWT($jwtCode){
        // Split a string by '.' 
        $jwt_values = explode('.', $jwtCode);
        $signing = $jwt_values[2];
        return $signing;
    }

    /**
     * Devuelve las cabeceras en las que tiene que llegar la autentificacion
     * 
     * ATENCION:: Para que la cabecera llegue en IONOS hay que subir tambien el .htaccess
     *  Sino el metodo no sera capaz de leer la cabecera:
     * 
     *          RewriteEngine On
     *          RewriteCond %{HTTP:Authorization} ^(.*)
     *          RewriteRule .* - [e=HTTP_AUTHORIZATION:%1]
     * 

     */
    private function getAuthorizationHeader(){
        if(empty($_SERVER["REDIRECT_HTTP_AUTHORIZATION"])){
            //Si es Server API = Apache
            $arrHeaders = apache_request_headers();
            if(empty($arrHeaders["Authorization"])){
                return "";
            }
            else{
                return $arrHeaders["Authorization"];
            }
        }
            
        return $_SERVER["REDIRECT_HTTP_AUTHORIZATION"];
    }


}